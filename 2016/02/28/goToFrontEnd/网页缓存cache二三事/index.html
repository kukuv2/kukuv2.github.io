<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>网页缓存cache二三事 | kukuv Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言一个网页是如何在浏览器上进行缓存的,其中涉及了哪些机制,有哪些技术可以采用,如何才能最大化利用缓存.个人觉得这些知识点都是一个前端工程师必须了解的.曾经在面试的时候被问过一个问题,”有没有不返回304,同时又使用了缓存的情况?”.当时因为对缓存机制了解不深,所以答不上来.下面我总结一下这方面的知识.
通过 HTTP 报头Cache-Control,Expires(响应报头)这两个响应报头是浏览">
<meta property="og:type" content="article">
<meta property="og:title" content="网页缓存cache二三事">
<meta property="og:url" content="http://yoursite.com/2016/02/28/goToFrontEnd/网页缓存cache二三事/index.html">
<meta property="og:site_name" content="kukuv Blog">
<meta property="og:description" content="前言一个网页是如何在浏览器上进行缓存的,其中涉及了哪些机制,有哪些技术可以采用,如何才能最大化利用缓存.个人觉得这些知识点都是一个前端工程师必须了解的.曾经在面试的时候被问过一个问题,”有没有不返回304,同时又使用了缓存的情况?”.当时因为对缓存机制了解不深,所以答不上来.下面我总结一下这方面的知识.
通过 HTTP 报头Cache-Control,Expires(响应报头)这两个响应报头是浏览">
<meta property="og:image" content="https://segmentfault.com/img/bVqjrp">
<meta property="og:image" content="https://segmentfault.com/img/bVqjrT">
<meta property="og:image" content="https://segmentfault.com/img/bVqjxa">
<meta property="og:image" content="https://segmentfault.com/img/bVqFvn">
<meta property="og:updated_time" content="2016-02-28T06:58:24.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="网页缓存cache二三事">
<meta name="twitter:description" content="前言一个网页是如何在浏览器上进行缓存的,其中涉及了哪些机制,有哪些技术可以采用,如何才能最大化利用缓存.个人觉得这些知识点都是一个前端工程师必须了解的.曾经在面试的时候被问过一个问题,”有没有不返回304,同时又使用了缓存的情况?”.当时因为对缓存机制了解不深,所以答不上来.下面我总结一下这方面的知识.
通过 HTTP 报头Cache-Control,Expires(响应报头)这两个响应报头是浏览">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">

      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">

        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-goToFrontEnd/网页缓存cache二三事" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/28/goToFrontEnd/网页缓存cache二三事/" class="article-date">
  <time datetime="2016-02-28T06:58:24.000Z" itemprop="datePublished">2016-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/goToFrontEnd/">goToFrontEnd</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      网页缓存cache二三事
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一个网页是如何在浏览器上进行缓存的,其中涉及了哪些机制,有哪些技术可以采用,如何才能最大化利用缓存.个人觉得这些知识点都是一个前端工程师必须了解的.曾经在面试的时候被问过一个问题,”有没有不返回304,同时又使用了缓存的情况?”.当时因为对缓存机制了解不深,所以答不上来.下面我总结一下这方面的知识.</p>
<h2 id="通过-HTTP-报头"><a href="#通过-HTTP-报头" class="headerlink" title="通过 HTTP 报头"></a>通过 HTTP 报头</h2><h3 id="Cache-Control-Expires-响应报头"><a href="#Cache-Control-Expires-响应报头" class="headerlink" title="Cache-Control,Expires(响应报头)"></a>Cache-Control,Expires(响应报头)</h3><p>这两个响应报头是浏览器缓存机制的第一道坎.当你发起一个 GET 请求时,服务器返回的响应报头里含有这两个报头,那么你下一次发起请求时(以某种方式, F5刷新除外),在你设置的资源过期时间前浏览器都不会再次请求服务器,而是直接使用已经缓存的版本.并且 status code 是200.这也是我上面说的不是只有返回了304才会使用缓存</p>
<p><img src="https://segmentfault.com/img/bVqjrp" alt="clipboard.png"><br>在 chrome 里我们可以清楚的看到 status code 旁边写的是(from cache).响应报头大致的形式也就是像上面那张图一样.</p>
<h3 id="Last-Modified-ETag-响应报头-If-Modified-Since-If-None-Match-请求报头"><a href="#Last-Modified-ETag-响应报头-If-Modified-Since-If-None-Match-请求报头" class="headerlink" title="Last-Modified,ETag(响应报头);If-Modified-Since,If-None-Match(请求报头)"></a>Last-Modified,ETag(响应报头);If-Modified-Since,If-None-Match(请求报头)</h3><p>这几个报头可以说是浏览器缓存机制里的第二道坎.当你请求某个资源时,如上面的图,响应报头会设置 Last-Modified 和 ETag,Last-Modified 是这个资源的最后修改时间, ETag 是该资源的唯一标识符.这两个值会在你再一次请求该资源时以 If-Modified-Since 和 If-None-Match 的形式附在请求头里发给服务器由服务器判读该资源是否过期.如果没过期,返回304,如果过期了,返回带有响应主体也就是 content并且status code为200的响应.请求报头大致如下.这个过程称为服务器再认证.</p>
<p><img src="https://segmentfault.com/img/bVqjrT" alt="clipboard.png"></p>
<h3 id="这两种报头的作用区间"><a href="#这两种报头的作用区间" class="headerlink" title="这两种报头的作用区间"></a>这两种报头的作用区间</h3><p><img src="https://segmentfault.com/img/bVqjxa" alt="clipboard.png"><br>借用一张简洁的图来展示它们的作用区间的区别</p>
<h3 id="GET与-POST"><a href="#GET与-POST" class="headerlink" title="GET与 POST"></a>GET与 POST</h3><p>只有GET请求才会触发浏览器的缓存机制.这也是 GET和 POST 的区别之一. GET 的目的应该是请求资源并且不会对服务器上的数据产生改动,是幂等的.而 POST 的目的就是为了修改数据.所以对于一些GET 方法的Ajax也可以使用响应报头的方法进行缓存,  jQuery 里的 ajax 方法里的 cache=false 就只对 GET 方法有效,原理是在 url 后加上一个时间戳类似于 <a href="http://www.test.com?a=b_201510300000,以防止浏览器缓存请求" target="_blank" rel="external">http://www.test.com?a=b_201510300000,以防止浏览器缓存请求</a>.</p>
<h2 id="通过-manifest-html5"><a href="#通过-manifest-html5" class="headerlink" title="通过 manifest(html5)"></a>通过 manifest(html5)</h2><p>manifest 是 一种新的缓存方式,通过 manifest 可以让网页离线使用.下面我总结下在使用 manifest 的时候一些要注意的地方,应该工作上没有使用 manifest 的场景,所以不做过多的深入</p>
<ol>
<li>manifest文件 的 content-type必须是’text/cache-manifest’,不然浏览器会不识别这是缓存文件.</li>
<li>引入 manifest 的方式是<html lang="en" manifest="hello.manifest">,默认的引入的 html 文件也会被缓存.</html></li>
<li><p>manifest 文件的格式类似</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">bundle.js</span><br></pre></td></tr></table></figure>
<p>4.一旦浏览器缓存成功后,下一次浏览器会先使用缓存的文件,然后再发请求检查 manifest 文件是否有变化.所以在下次打开网页前,用户看到的还是旧的文件.你可以使用 window.applicationCache 来控制当发现 manifest 文件过期后自动刷新,这样来保证用户能看到新的内容.<br>5.manifest 文件的检查是根据类似于文件 md5的方式来检查的,也就是说如果你在 manifest 文件里加了一个新空行,浏览器也会认为 manifest 文件有更新,然后重新下载缓存文件以备下次使用.</p>
</li>
</ol>
<h2 id="通过-webStorageApi-html5"><a href="#通过-webStorageApi-html5" class="headerlink" title="通过 webStorageApi(html5)"></a>通过 webStorageApi(html5)</h2><p> webStorageApi 我主要讲一下 localStorage, 因为在工作中有使用场景.在开发新后台主页面的时候,左侧是一个很长的多级菜单,右面是 主内容.大概是这样</p>
<p><img src="https://segmentfault.com/img/bVqFvn" alt="图片描述"><br>当左侧菜单拉长时,点击链接跳到新页面,这时左侧菜单的滑动条也要保持在上个页面的滑动位置,这时可以监听点击菜单事件,通过 localStorage 来保存滑动条高度<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(target.attr(<span class="string">'href'</span>) !== <span class="string">"javascript:void(0);"</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.localStorage)&#123;</span><br><span class="line">        localStorage.setItem(<span class="string">"siteScroll"</span>, scrollTop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    $(<span class="string">'.nav-secondary'</span>).scrollTop(target.offset().top - menuOffsetTop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下次页面打开的时候再获取并设置滑动条的位置<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.localStorage)&#123;</span><br><span class="line">     <span class="keyword">var</span> scrollTop = localStorage.getItem(<span class="string">"siteScroll"</span>);</span><br><span class="line">     $(<span class="string">'.nav-secondary'</span>).scrollTop(scrollTop);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>因本人水平有限,总结过程中难免出错,还望大家能够指出,谢谢!</p>
</blockquote>
<p>查阅应用了以下书籍和内容</p>
<blockquote>
<p><a href="http://www.alloyteam.com/2012/03/web-cache-2-browser-cache/" target="_blank" rel="external">http://www.alloyteam.com/2012/03/web-cache-2-browser-cache/</a><br>html5高级程序设计</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/28/goToFrontEnd/网页缓存cache二三事/" data-id="cil67ldqn0006e090q722u8sp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/02/28/nodejs/sails学习/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          sails学习
        
      </div>
    </a>
  
  
    <a href="/2016/02/28/goToFrontEnd/浏览器同源策略以及跨域请求时可能遇到的问题/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">浏览器同源策略以及跨域请求时可能遇到的问题</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/goToFrontEnd/">goToFrontEnd</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/goToFrontEnd/js/">js</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodeJs/">nodeJs</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/02/28/goToFrontEnd/js/javascript的基本类型和与操作符结合时的类型转换/">javascript的基本类型和与操作符结合时的类型转换</a>
          </li>
        
          <li>
            <a href="/2016/02/28/nodejs/sails学习/">sails学习</a>
          </li>
        
          <li>
            <a href="/2016/02/28/goToFrontEnd/网页缓存cache二三事/">网页缓存cache二三事</a>
          </li>
        
          <li>
            <a href="/2016/02/28/goToFrontEnd/浏览器同源策略以及跨域请求时可能遇到的问题/">浏览器同源策略以及跨域请求时可能遇到的问题</a>
          </li>
        
          <li>
            <a href="/2016/02/28/goToFrontEnd/js/JavaScript函数声明与函数表达式/">JavaScript函数声明与函数表达式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 kukuv<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>